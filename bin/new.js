import logger from '@novice1/logger'
import fs from 'fs'
import path from 'path'
import { mkdirp } from 'mkdirp'
import { exec as cp_exec } from 'child_process'

const debug = logger.debugger('nfs:cmd:new')
const __dirname = import.meta.dirname

const gitignoreContent=`
/dist

#
.DS_Store

# IDEs
/.idea
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp and cache directory
.temp
.cache

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
`

/**
 *
 * @param {import('commander').Command} program
 * @returns {(this: import('commander').Command, ...args: any[]) => void | Promise<void>} action
 */
export default function newCmd(program) {
    /**
     * @param {string} moduleName
     */
    return function action(moduleName) {
        const opts = this.opts();
        const modulePath = path.join(process.cwd(), moduleName)
        const isBasic = opts.template == 'basic'
        const isWide = opts.template == 'wide'

        // --debug
        if (program.opts().debug) {
            logger.Debug.enable('nfs:*');
        }

        debug.debug(`new module: ${moduleName}`)

        if (fs.existsSync(modulePath)) {
            logger.error(`Folder "${moduleName}" already exists.`);
            return process.exit(1)
        }

        // create folder
        mkdirp.sync(modulePath);

        // copy template files
        fs.cpSync(path.join(__dirname, '..', 'assets', 'templates', opts.template), modulePath, { recursive: true,  })

        // create package.json
        const packageJsonContent = {
            "name": `${moduleName}`,
            "version": "1.0.0",
            "description": `${opts.description || ''}`,
            "author": `${opts.author || ''}`,
            "license": `${opts.license || 'UNLICENSED'}`,
            "private": true,
            "scripts": {
                "build": "tsc",
                "dev": "nodemon",
                "lint": "eslint .",
                "start": "node dist/index.js",
                "test": "echo \"Error: no test specified\" && exit 1"
            },
            "dependencies": {}
        };
        if (isWide) {
            packageJsonContent.scripts['test'] = 'kaukau -r ts-node/register -f src --ext .spec.ts'
            packageJsonContent.scripts['test:e2e'] = 'kaukau --require ts-node/register --config test/kaukau-e2e.mjs'
        }
        fs.writeFileSync(path.join(modulePath, 'package.json'), JSON.stringify(packageJsonContent, null, '    '));

        // create config files
        let dotenvContent = 'PORT=8080\n'
        if (!isBasic) {
            dotenvContent += 'LOG_LEVEL=2\n'
            dotenvContent += 'LOG_DEBUG=\n'
        }
        fs.writeFileSync(path.join(modulePath, '.env'), dotenvContent);
        fs.writeFileSync(path.join(modulePath, '.gitignore'), gitignoreContent);
        fs.writeFileSync(path.join(modulePath, 'nodemon.json'), JSON.stringify({
            "watch": [
                "src",
                ".env",
                ".env.development.local"
            ],
            "ext": "ts,json",
            "ignore": [
                "src/**/*.spec.ts"
            ],
            "exec": "dotenvx run -- ts-node ./src/index.ts"
        }, null, '    '));

        // install dependencies
        let installCommands = `cd ${modulePath} && \
        npm i @dotenvx/dotenvx @novice1/api-doc-generator @novice1/frame @novice1/logger @novice1/routing tslib && \
        npm i -D @eslint/eslintrc @eslint/js @stylistic/eslint-plugin-js @types/express @types/node @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint globals nodemon ts-node typescript typescript-eslint && \
        npm i joi`;
        if (isWide) {
            installCommands += ` && \
            npm i -D @types/chai @types/mocha @types/supertest @types/swagger-ui-express chai@4 eslint-plugin-mocha kaukau supertest`
        }
        const cp = cp_exec(installCommands);

        logger.info(`installing dependencies`);
    };
}

